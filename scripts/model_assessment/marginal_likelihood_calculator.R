#' computing log marginal likelihood using the log likelihoods sampled from power posterior inferences
#' @param x a vector of powers
#' @param f a list where each element is a vector of log likelihoods sampled under a given power
#' @return log marginal likelihoods computed using the stepping-stone integrator and the path-sampling (thermodynamic) integrator, respectively
computeMarginalLikelihood <- function(x, f) {
  
  # calculate the marginal likelihood using stepping-stone estimator
  marginallikelihood_ss <- steppingStoneIntegrator(x, f)
  
  # calculate the marginal likelihood using path-sampling estimator w/ trapezoid rule
  mean_likelihoods <- sapply(f, mean)
  marginallikelihood_psTrap = pathSamplingIntegratorTrapezoid(x, mean_likelihoods)

  res <- c(marginallikelihood_ss, marginallikelihood_psTrap)
  names(res) <- c("ss", "psTrap")
  
  return(res)
}

#' computing log marginal likelihood using the log likelihoods sampled from power posterior inferences with the stepping-stone integrator
#' @param x a vector of powers
#' @param f a list where each element is a vector of log likelihoods sampled under a given power
#' @return a log marginal likelihood
steppingStoneIntegrator = function(x, f) {
  res = 0
  num_stones = length(x)
  for (i in 2:num_stones) {
    
    # get the samples for this stone
    these_samples = f[[i]]
    
    # get the scaling factor and rescale
    factor = max(these_samples)
    these_samples = these_samples - factor
    
    # compute the mean likelihood
    mean_likelihood = mean(exp(these_samples * (x[i - 1] - x[i])))
    
    # increment the marginal likelihood estimate
    res = res + log(mean_likelihood) + (x[i - 1] - x[i]) * factor
  }
  
  return(res)
}

#' computing log marginal likelihood using the log likelihoods sampled from power posterior inferences with the path-sampling (thermodynamic) integrator, respectively
#' @param x a vector of powers
#' @param f a vector of mean log likelihoods where each one corresponds to a given power
#' @return a log marginal likelihood
pathSamplingIntegratorTrapezoid = function(x, f) {
  res = 0
  num_stones = length(x)
  for(i in 1:(num_stones - 1)) {
    res = res + (f[i] + f[i+1]) * (x[i] - x[i+1]) / 2
  }
  return(res)
}

#' computing a combined log marginal likelihood from replicate power posterior log files generated by BEAST
#' @param MLElog_paths file paths of the power posterior log files
#' @param input_folder path of the directory that contains the power posterior log files (will be used to get the file paths if \code{MLElog_paths} is not provided)
#' @return a log marginal likelihood computed using the stepping-stone integrator
get_combined_marginal_likelihood <- function(input_folder = NULL, MLElog_paths = NULL) {
  if (is.null(MLElog_paths) && !is.null(input_folder)) {
    MLElog_paths <- list.files(input_folder, recursive = T, all.files = T, full.names = T, pattern = "*MLE.*.log$")
  } else if (is.null(input_folder) && is.null(MLElog_paths)) {
    stop("at least one needs to be provided")
  }
  
  powerposterior_likelihood_df <- lapply(MLElog_paths, function(x) read.table(x, header = T, sep = "\t", stringsAsFactors = F, check.names = F))
  powerposterior_likelihood_df <- do.call(rbind, powerposterior_likelihood_df)
  powerposterior_likelihood_df <- powerposterior_likelihood_df[order(powerposterior_likelihood_df$pathLikelihood.theta, decreasing = T), ]
  
  powers <- sort(unique(powerposterior_likelihood_df$pathLikelihood.theta), decreasing = T)
  powerposterior_likelihoods <- lapply(powers, function(x) powerposterior_likelihood_df$pathLikelihood.delta[powerposterior_likelihood_df$pathLikelihood.theta == x])
  marginal_likelihoods <- computeMarginalLikelihood(powers, powerposterior_likelihoods)
  return(as.numeric(marginal_likelihoods["ss"]))
}
